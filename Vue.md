## 1、说说你对SPA的理解，它的优点和缺点分别是什么？

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点**
  * 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
  * 基于上面一点，SPA 相对对服务器压力小；
  * 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

## 2、写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

官网推荐推荐的使用key，应该理解为“使用唯一id作为key”。因为index作为key，和不带key的效果是一样的。index作为key时，每个列表项的index在变更前后也是一样的，都是直接判断为sameVnode然后复用。

说到底key的作用是比较两个节点是否相同，不相同就删除旧的创建新的。

正是因为带唯一key时每次更新都不能找到可复用的节点，不但要销毁和创建vnode，在DOM里添加移除节点对性能的影响更大。所以会才说“不带key可能性能更好”。

其实在不带key的作用下，节点可以就地复用，省去了销毁创建的时间，(上面的例子中，对于删除节点的操作，列表会把原来的删除掉，增加新的节点),同时只需要修改文本内容，但是为什么要依赖于key呢，因为这种就地复用的场景只适用于简单的无状态组件，对于大多数场景来说，列表组件都有自己的状态。

举个例子：一个新闻列表，可点击列表项来将其标记为"已访问"，可通过tab切换“娱乐新闻”或是“社会新闻”。

不带key属性的情况下，在“娱乐新闻”下选中第二项然后切换到“社会新闻”，"社会新闻"里的第二项也会是被选中的状态，因为这里复用了组件，保留了之前的状态。要解决这个问题，可以为列表项带上新闻id作为唯一key，那么每次渲染列表时都会完全替换所有组件，使其拥有正确状态。

这只是个简单的例子，实际应用会更复杂。带上唯一key虽然会增加开销，但是对于用户来说基本感受不到差距，而且能保证组件状态正确，这应该就是为什么推荐使用唯一id作为key的原因。至于具体怎么使用，就要根据实际情况来选择了。

## 从0到1自己构架一个vue项目，说说有哪些步骤、哪些重要插件、目录结构你会怎么组织
在看到这个问题的时候，一定要分环境进行讨论：现在结合一些框架,可以实现很多的能力，包括跨端编译等等
H5 PC 后台管理系统 小程序 Native 不同的项目的需求略有差异，因此需要分情况进行讨论。

小程序:
  这里限定了vue框架 那可以使用 mpvue WePY来开发小程序项目。
H5:
  这里主要是指微信页面、Webview中的H5页面开发
PC: 
  这里为什么要单独将这个东西拿出来，是因为，对于官网来说，可以需要ssr服务端渲染，
  考虑seo优化等能力，比如Vue的Nuxt.js
后台管理系统：
  主要的目的在于数据的配置，权限的控制，数据报表的展示、日志功能等通常叫做CMS 或者 OA
Native：
  可以使用 weex 或者 electron 
通用型：
  可以使用uni-app 来创建项目 编译多端代码

基于@vue/cli 选型
  后台管理系统中，vue-router 和vuex 都是必选的 其他的根据需求自行考虑。
  * ES6/7 or Typescript?

## 你知道vue的模板语法用的是哪个web模板引擎的吗？
  vue 中使用的模板引擎是 mustache.js。模板引擎并不少见，但是平时开发中没有强制要求
  [mustache demo 示例](https://www.yinzhuoei.com/index.php/archives/110/)

## 请说一下Vue中响应式数据的理解？

1、Vue中的响应式数据实现用到了`Object.defineProperty`这个api。
2、默认Vue在初始化数据时，会给data中的属性使用`Object.defineProperty`重新定义所有属性，当页面获取到对应的属性时，会进行依赖收集，所谓的依赖收集，就是收集（当前组件的watcher），如果属性发生变化会通知相关的依赖进行更新操作。

源码中定义了defineReactive这个方法，使用Object.defineProperty将属性进行劫持(只会劫持已经存在的属性)，数组则是通过重写数组的方法来实现的。如果树多层对象，则是通过递归来实现的劫持的。Vue3中使用了proxy这个api实现。

内部依赖收集是怎样做到的，每个属性都拥有自己的dep属性，存放它所依赖的watcher，当属性变化后，会通知自己对应的watcher去更新，（其实后面会讲到每个对象类型自己本身也拥有一个dep属性，这个在$set面试题目中进行讲解）

new Vue的时候会执行 `initState` 这个函数, 然后是 observe 这个函数，new Observer 时候判断了是数组还是对象，如果是对象的话，调用 defineReactive 对每一个属性进行get 和 set的数据劫持，在get的时候还会进行依赖收集, 数据改变的时候派发更新操作。

> 这里会涉及到性能优化的相关内容 （1）对象层次过深，性能会比较差 （2）不需要响应式的数据不要放在data中 （3）Object.freeze()可以冻结数据

## 谈一下你对MVVM的理解
* 传统的MVC指的是,用户操作操作会请求服务端路由，路由会调用对应的控制器来处理,控制器会获取数据，将结果返回给前端，页面重新渲染。

* MVVM: 传统的前端会将数据手动的渲染到页面上，mvvm模式不需要用户操作dom，只需要将数据放在viewmodel层上，会自动将数据渲染到页面中，视图变化会通知viewModel层更新数据，viewModel就是我们Mvvm模式中的桥梁。


## vue 如何检测数组变化
核心答案:
数组考虑性能的原因没有使用defineProperty对数组的每一项进行拦截，而是选择重写数组的方法（push、shift、pop、splice、unshift、sort、reverse） 方法进行重写。

补充答案： 在vue中修改数组的索引和长度是无法检测到的，需要通过以上7种变异方法修改数组才会触发数组对应的watcher进行更新，数组中如果是对象数据类型也会进行递归劫持。

> 那如果想要更改索引更新数据怎么办？可以通过 Vue.$set() 进行处理，核心内部使用的是splice方法。

## vue中的模板编译原理
核心答案:
如何将template转换成 render 函数（这里要注意的是我们在开发的过程中尽量不要使用template）因为将template转化为 render 方法需要在运行时进行编译操作，这样会有性能损耗。同时引用带有compile包的vue体积也会变大，默认.vue中的tempplate处理hi通过vue-loader处理的，并不是运行时候进行编译的

* 1、将template模板转换成 ast 语法树 -- parseHTML 这个过程中会涉及一些正则表达式的解析
* 2、对静态语法糖做静态标记，哪些是静态节点，哪些是动态节点
* 3、重新生成代码


## 生命周期钩子是如何实现的
核心答案:

vue的生命周期钩子是一个回调函数，当创建组件实例的过程中会调用对应的钩子方法。

补充回答:
内部主要是使用callhook方法来调用对应的方法，核心是一个发布订阅模式，将钩子函数订阅好（内部采用数组的方式存储），在对应的阶段进行发布！


## v-if 和 v-for 哪个优先级更高，如果同时出现，应该怎么优化得到更好的性能？

如何回答这个问题？ 
1、先给结论，v-for的优先级是高于v-if的，我之前比较好奇这个问题，写了一个简单的测试demo，后来在vue源码的compiler模块中，发现它解析抽象语法树中有一段逻辑是判断这两个指令的，是先判断 v-for 然后再判断 v-if的。
2、生成的render函数 无论如何都会先执行循环，循环内部再执行判断条件，这样的话无论如何循环都避免不了，这样比较浪费性能。
3、要避免出现这种情况，最好在外面套一层template,在这一层执行v-if 判断，然后在内部执行v-for循环。







  
